<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - OBJLoader + MTLLoader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>
 
	<body>
		<script src="./js/lib/three/three.min.js"></script>
 
		<script src="./js/lib/three/DDSLoader.js"></script>
		<script src="./js/lib/three/MTLLoader.js"></script>
		<script src="./js/lib/three/OBJLoader.js"></script>
        <!-- <script src="./js/lib/three/TrackballControls.js"></script>
		<script src="./js/lib/three/Detector.js"></script>
		<script src="./js/lib/three/stats.min.js"></script> -->
 
		<script>
 
		    // 容器
			var container,
			stats,
			// 控制器
			controls;
 
			// 镜头
			var camera,
			
			// 场景
			scene, 
			// 渲染
			renderer;
 
			var mouseX = 0, mouseY = 0;
 
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
 
 
			init();
			animate();
 
 
			function init() {
 
				container = document.createElement( 'div' );
				document.body.appendChild( container );
                
				//创建一个一个视角
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
				
				//设置视角离原点的位置（眼睛距离模型的距离） 
				camera.position.z = 700;
 
				
				
				
			//控制器
			controls = new THREE.TrackballControls( camera );
			//设置旋转速度
			controls.rotateSpeed = 3;
 
			// 使动画循环使用时阻尼或自转 意思是否有惯性 
			controls.enableDamping = true; 
			//是否可以缩放 
			controls.enableZoom = true; 
			//是否自动旋转 
			controls.autoRotate = true; 
			//设置相机距离原点的最远距离 
			controls.minDistance = 500; 
			//设置相机距离原点的最远距离 
			controls.maxDistance = 2000; 
			//是否开启右键拖拽 
			controls.enablePan = true;
				
				
				// scene
 
				scene = new THREE.Scene();
 
				var ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );
 
				var pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( pointLight );
				scene.add( camera );
 
                // model  开始创建模型
 
				var onProgress = function ( xhr ) {
 
					if ( xhr.lengthComputable ) {
 
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
 
					}
 
				};
                //报错通知
				var onError = function ( xhr ) { };
 
				THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
                
				// 加载mtl
				new THREE.MTLLoader()
					.setPath( '' )
					.load( 'Mountains2.mtl', function ( materials ) {
 
						materials.preload();
                        
						// 加载obj
						new THREE.OBJLoader()
							.setMaterials( materials )
							.setPath( '' )
							.load( 'Mountains2.obj', function ( object ) {
 
								object.position.y = - 95;
								scene.add( object );
 
							}, onProgress, onError );
 
					} );
 
				//
 
				renderer = new THREE.WebGLRenderer({antialias: false,
						alpha: true}); // 设置透明);
						// 设置分辨率
				renderer.setPixelRatio( window.devicePixelRatio );
				// 设置渲染尺寸
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
 
				
 
			
	             // 自适应监听
				window.addEventListener( 'resize', onWindowResize, false );
 
			}
 
			function onWindowResize() {
 
				camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
 
			renderer.setSize( window.innerWidth, window.innerHeight );
 
			}
 
			function onDocumentMouseMove( event ) {
 
				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;
 
			}
 
			
             // 时刻渲染
			function animate() {
				controls.update();
				renderer.render( scene, camera );
				requestAnimationFrame( animate );
			}
 
			function render() {
 
				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
 
				camera.lookAt( scene.position );
 
				renderer.render( scene, camera );
 
			}
 
		</script>
 
	</body>
</html>